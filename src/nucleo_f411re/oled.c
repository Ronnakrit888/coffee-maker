#include "oled_driver.h"
#include <string.h> // Includes memset and strlen

// Display Buffer definition
uint8_t SSD1306_Buffer[SSD1306_WIDTH * (SSD1306_HEIGHT / 8)];

// Standard 8x8 ASCII Font Data (95 characters: ASCII 0x20 ' ' to 0x7E '~')
// Each character is 8 bytes wide. Each byte represents 8 vertical pixels (rows 0-7).
static const uint8_t Font_8x8[][FONT_8X8_WIDTH] = {
    // 0x20: Space
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // 0x21: !
    {0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00},
    // 0x22: "
    {0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},
    // 0x23: #
    {0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14, 0x00, 0x00},
    // 0x24: $
    {0x00, 0x24, 0x54, 0x55, 0x22, 0x41, 0x00, 0x00},
    // 0x25: %
    {0x00, 0x41, 0x22, 0x08, 0x14, 0x61, 0x00, 0x00},
    // 0x26: &
    {0x00, 0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00},
    // 0x27: '
    {0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00},
    // 0x28: (
    {0x00, 0x00, 0x1c, 0x22, 0x41, 0x00, 0x00, 0x00},
    // 0x29: )
    {0x00, 0x00, 0x41, 0x22, 0x1c, 0x00, 0x00, 0x00},
    // 0x2a: *
    {0x00, 0x14, 0x22, 0x7f, 0x22, 0x14, 0x00, 0x00},
    // 0x2b: +
    {0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00, 0x00},
    // 0x2c: ,
    {0x00, 0x00, 0x00, 0x60, 0x20, 0x00, 0x00, 0x00},
    // 0x2d: -
    {0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00},
    // 0x2e: .
    {0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00},
    // 0x2f: /
    {0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00},
    // 0x30: 0
    {0x00, 0x3e, 0x51, 0x49, 0x45, 0x3e, 0x00, 0x00},
    // 0x31: 1
    {0x00, 0x00, 0x42, 0x7f, 0x40, 0x00, 0x00, 0x00},
    // 0x32: 2
    {0x00, 0x42, 0x61, 0x51, 0x49, 0x46, 0x00, 0x00},
    // 0x33: 3
    {0x00, 0x21, 0x41, 0x49, 0x4d, 0x33, 0x00, 0x00},
    // 0x34: 4
    {0x00, 0x18, 0x14, 0x12, 0x7f, 0x10, 0x00, 0x00},
    // 0x35: 5
    {0x00, 0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00},
    // 0x36: 6
    {0x00, 0x3c, 0x4a, 0x49, 0x49, 0x30, 0x00, 0x00},
    // 0x37: 7
    {0x00, 0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00},
    // 0x38: 8
    {0x00, 0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00},
    // 0x39: 9
    {0x00, 0x06, 0x49, 0x49, 0x29, 0x1e, 0x00, 0x00},
    // 0x3a: :
    {0x00, 0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00},
    // 0x3b: ;
    {0x00, 0x00, 0x56, 0x36, 0x00, 0x00, 0x00, 0x00},
    // 0x3c: <
    {0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00},
    // 0x3d: =
    {0x00, 0x00, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00},
    // 0x3e: >
    {0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00},
    // 0x3f: ?
    {0x00, 0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00},
    // 0x40: @
    {0x00, 0x32, 0x49, 0x59, 0x4f, 0x30, 0x00, 0x00},
    // 0x41: A
    {0x00, 0x7e, 0x09, 0x09, 0x09, 0x7e, 0x00, 0x00},
    // 0x42: B
    {0x00, 0x7f, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00},
    // 0x43: C
    {0x00, 0x3e, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00},
    // 0x44: D
    {0x00, 0x7f, 0x41, 0x41, 0x22, 0x1c, 0x00, 0x00},
    // 0x45: E
    {0x00, 0x7f, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00},
    // 0x46: F
    {0x00, 0x7f, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00},
    // 0x47: G
    {0x00, 0x3e, 0x41, 0x49, 0x49, 0x7a, 0x00, 0x00},
    // 0x48: H
    {0x00, 0x7f, 0x08, 0x08, 0x08, 0x7f, 0x00, 0x00},
    // 0x49: I
    {0x00, 0x00, 0x41, 0x7f, 0x41, 0x00, 0x00, 0x00},
    // 0x4a: J
    {0x00, 0x20, 0x40, 0x41, 0x3f, 0x01, 0x00, 0x00},
    // 0x4b: K
    {0x00, 0x7f, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00},
    // 0x4c: L
    {0x00, 0x7f, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00},
    // 0x4d: M
    {0x00, 0x7f, 0x02, 0x0c, 0x02, 0x7f, 0x00, 0x00},
    // 0x4e: N
    {0x00, 0x7f, 0x04, 0x08, 0x10, 0x7f, 0x00, 0x00},
    // 0x4f: O
    {0x00, 0x3e, 0x41, 0x41, 0x41, 0x3e, 0x00, 0x00},
    // 0x50: P
    {0x00, 0x7f, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00},
    // 0x51: Q
    {0x00, 0x3e, 0x41, 0x51, 0x21, 0x5e, 0x00, 0x00},
    // 0x52: R
    {0x00, 0x7f, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00},
    // 0x53: S
    {0x00, 0x46, 0x49, 0x49, 0x49, 0x31, 0x00, 0x00},
    // 0x54: T
    {0x00, 0x01, 0x01, 0x7f, 0x01, 0x01, 0x00, 0x00},
    // 0x55: U
    {0x00, 0x3f, 0x40, 0x40, 0x40, 0x3f, 0x00, 0x00},
    // 0x56: V
    {0x00, 0x1f, 0x20, 0x40, 0x20, 0x1f, 0x00, 0x00},
    // 0x57: W
    {0x00, 0x3f, 0x40, 0x38, 0x40, 0x3f, 0x00, 0x00},
    // 0x58: X
    {0x00, 0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00},
    // 0x59: Y
    {0x00, 0x07, 0x08, 0x70, 0x08, 0x07, 0x00, 0x00},
    // 0x5a: Z
    {0x00, 0x41, 0x49, 0x4d, 0x51, 0x61, 0x00, 0x00},
    // 0x5b: [
    {0x00, 0x00, 0x7f, 0x41, 0x41, 0x00, 0x00, 0x00},
    // 0x5c: \ (Backslash)
    {0x00, 0x41, 0x22, 0x14, 0x08, 0x41, 0x00, 0x00},
    // 0x5d: ]
    {0x00, 0x00, 0x41, 0x41, 0x7f, 0x00, 0x00, 0x00},
    // 0x5e: ^
    {0x00, 0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00},
    // 0x5f: _
    {0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00},
    // 0x60: `
    {0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00},
    // 0x61: a
    {0x00, 0x00, 0x20, 0x54, 0x54, 0x78, 0x00, 0x00},
    // 0x62: b
    {0x00, 0x7f, 0x48, 0x4c, 0x44, 0x3c, 0x00, 0x00},
    // 0x63: c
    {0x00, 0x00, 0x38, 0x44, 0x44, 0x20, 0x00, 0x00},
    // 0x64: d
    {0x00, 0x3c, 0x44, 0x44, 0x48, 0x7f, 0x00, 0x00},
    // 0x65: e
    {0x00, 0x00, 0x38, 0x54, 0x54, 0x18, 0x00, 0x00},
    // 0x66: f
    {0x00, 0x08, 0x7e, 0x09, 0x01, 0x02, 0x00, 0x00},
    // 0x67: g
    {0x00, 0x00, 0x06, 0x49, 0x49, 0x3f, 0x00, 0x00},
    // 0x68: h
    {0x00, 0x7f, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00},
    // 0x69: i
    {0x00, 0x00, 0x44, 0x7d, 0x40, 0x00, 0x00, 0x00},
    // 0x6a: j
    {0x00, 0x20, 0x40, 0x44, 0x3d, 0x00, 0x00, 0x00},
    // 0x6b: k
    {0x00, 0x7f, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00},
    // 0x6c: l
    {0x00, 0x00, 0x41, 0x7f, 0x40, 0x00, 0x00, 0x00},
    // 0x6d: m
    {0x00, 0x7c, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00},
    // 0x6e: n
    {0x00, 0x7c, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00},
    // 0x6f: o
    {0x00, 0x00, 0x38, 0x44, 0x44, 0x38, 0x00, 0x00},
    // 0x70: p
    {0x00, 0x7c, 0x14, 0x14, 0x14, 0x08, 0x00, 0x00},
    // 0x71: q
    {0x00, 0x08, 0x14, 0x14, 0x18, 0x7c, 0x00, 0x00},
    // 0x72: r
    {0x00, 0x7c, 0x08, 0x04, 0x04, 0x08, 0x00, 0x00},
    // 0x73: s
    {0x00, 0x00, 0x48, 0x54, 0x54, 0x20, 0x00, 0x00},
    // 0x74: t
    {0x00, 0x04, 0x3f, 0x44, 0x40, 0x20, 0x00, 0x00},
    // 0x75: u
    {0x00, 0x3c, 0x40, 0x40, 0x20, 0x7c, 0x00, 0x00},
    // 0x76: v
    {0x00, 0x1c, 0x20, 0x40, 0x20, 0x1c, 0x00, 0x00},
    // 0x77: w
    {0x00, 0x3c, 0x40, 0x30, 0x40, 0x3c, 0x00, 0x00},
    // 0x78: x
    {0x00, 0x64, 0x1c, 0x08, 0x1c, 0x64, 0x00, 0x00},
    // 0x79: y
    {0x00, 0x04, 0x08, 0x70, 0x08, 0x04, 0x00, 0x00},
    // 0x7a: z
    {0x00, 0x44, 0x64, 0x54, 0x4c, 0x44, 0x00, 0x00},
    // 0x7b: {
    {0x00, 0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00},
    // 0x7c: |
    {0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00},
    // 0x7d: }
    {0x00, 0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00},
    // 0x7e: ~
    {0x00, 0x04, 0x02, 0x02, 0x02, 0x04, 0x00, 0x00}
};


// Dummy delay function (essential for bit-banging I2C)
static void I2C_Delay(void)
{
    volatile uint32_t i;
    for (i = 0; i < 100; i++)
        ; // Adjust based on your clock speed
}

// --- Low-level I2C Bit-Banging Functions (No Change) ---

static void SDA_Input_Mode()
{
    OLED_SDA_PORT->MODER &= ~(3U << (OLED_SDA_PIN * 2));
}
static void SDA_Output_Mode()
{
    OLED_SDA_PORT->MODER &= ~(3U << (OLED_SDA_PIN * 2));
    OLED_SDA_PORT->MODER |= (1U << (OLED_SDA_PIN * 2));
}
static void I2C_Start(void)
{
    SDA_Output_Mode();
    OLED_SDA_SET();
    OLED_SCK_SET();
    I2C_Delay();
    OLED_SDA_CLR();
    I2C_Delay();
    OLED_SCK_CLR();
    I2C_Delay();
}
static void I2C_Stop(void)
{
    SDA_Output_Mode();
    OLED_SDA_CLR();
    OLED_SCK_SET();
    I2C_Delay();
    OLED_SDA_SET();
    I2C_Delay();
}
static bool I2C_WriteByte(uint8_t data)
{
    uint8_t i;
    bool ack;
    for (i = 0; i < 8; i++)
    {
        if ((data << i) & 0x80)
        {
            OLED_SDA_SET();
        }
        else
        {
            OLED_SDA_CLR();
        }
        I2C_Delay();
        OLED_SCK_SET();
        I2C_Delay();
        OLED_SCK_CLR();
    }
    OLED_SDA_SET();
    SDA_Input_Mode();
    I2C_Delay();
    OLED_SCK_SET();
    I2C_Delay();
    ack = OLED_SDA_READ();
    OLED_SCK_CLR();
    SDA_Output_Mode();
    I2C_Delay();
    return !ack;
}
static void OLED_Write(uint8_t type, uint8_t data)
{
    I2C_Start();
    I2C_WriteByte(SSD1306_I2C_ADDR);
    I2C_WriteByte(type);
    I2C_WriteByte(data);
    I2C_Stop();
}
#define OLED_WriteCommand(command) OLED_Write(0x00, (command))

void OLED_Init(void)
{
    for (volatile int i = 0; i < 100000; i++)
        ;

    // Initial sequence of commands for a 128x64 display
    OLED_WriteCommand(0xAE); // Display OFF
    OLED_WriteCommand(0xD5); // Set Display Clock Divide Ratio / Oscillator Frequency
    OLED_WriteCommand(0x80);
    OLED_WriteCommand(0xA8); // Set Multiplex Ratio (height-1)
    OLED_WriteCommand(0x3F); // For 64px height
    OLED_WriteCommand(0xD3); // Set Display Offset
    OLED_WriteCommand(0x00);
    OLED_WriteCommand(0x40); // Set Start Line
    OLED_WriteCommand(0x8D); // Charge Pump Setting
    OLED_WriteCommand(0x14); // Enable charge pump
    OLED_WriteCommand(0x20); // Set Memory Addressing Mode
    OLED_WriteCommand(0x00); // Horizontal Addressing Mode
    OLED_WriteCommand(0xA1); // Segment Remap (0xA0 or 0xA1)
    OLED_WriteCommand(0xC8); // Com scan direction (0xC0 or 0xC8)
    OLED_WriteCommand(0xDA); // COM Pins hardware configuration
    OLED_WriteCommand(0x12); // Sequential COM pin configuration
    OLED_WriteCommand(0x81); // Contrast Control
    OLED_WriteCommand(0xCF);
    OLED_WriteCommand(0xD9); // Set Pre-charge period
    OLED_WriteCommand(0xF1);
    OLED_WriteCommand(0xDB); // Set VCOMH Deselect level
    OLED_WriteCommand(0x40);
    OLED_WriteCommand(0xA4); // Entire Display ON/OFF (Resume to RAM content)
    OLED_WriteCommand(0xA6); // Set Normal Display (0xA7 for Inverse)
    OLED_WriteCommand(0x2E); // Deactivate Scroll
    OLED_WriteCommand(0xAF); // Display ON

    OLED_Fill(0);
    OLED_UpdateScreen();
}

void OLED_Fill(uint8_t color)
{
    memset(SSD1306_Buffer, (color == 1) ? 0xFF : 0x00, sizeof(SSD1306_Buffer));
}

void OLED_UpdateScreen(void)
{
    uint16_t i;
    for (i = 0; i < 8; i++)
    {
        OLED_WriteCommand(0xB0 + i);
        OLED_WriteCommand(0x00);
        OLED_WriteCommand(0x10);

        I2C_Start();
        I2C_WriteByte(SSD1306_I2C_ADDR);
        I2C_WriteByte(0x40); // Data mode

        for (uint8_t j = 0; j < SSD1306_WIDTH; j++)
        {
            I2C_WriteByte(SSD1306_Buffer[i * SSD1306_WIDTH + j]);
        }
        I2C_Stop();
    }
}

void OLED_DrawPixel(uint8_t x, uint8_t y, bool color)
{
    if (x >= SSD1306_WIDTH || y >= SSD1306_HEIGHT)
    {
        return;
    }

    uint16_t index = x + (y / 8) * SSD1306_WIDTH;
    uint8_t bit = (1 << (y % 8));

    if (color)
    {
        SSD1306_Buffer[index] |= bit;
    }
    else
    {
        SSD1306_Buffer[index] &= ~bit;
    }
}


void OLED_DrawChar(uint8_t x, uint8_t y, char ch, bool color)
{
    // y must be page-aligned for an 8x8 font (y % 8 == 0)
    if (y % FONT_8X8_HEIGHT != 0)
        return;
        
    // Boundary check: ensure the whole character fits
    if (x > SSD1306_WIDTH - FONT_8X8_WIDTH)
        return;

    // Character index in the font array: ' ' (ASCII 32) is index 0
    uint8_t char_index = ch - 0x20; 

    // Check if the character is within the supported ASCII range (0x20 to 0x7E)
    if (ch < 0x20 || ch > 0x7E)
    {
        char_index = 0; // Fallback to space character
    }
    
    // Starting memory position in the buffer (Page = y / 8, Col = x)
    uint8_t start_page = y / FONT_8X8_HEIGHT;
    uint16_t buffer_index_start = x + start_page * SSD1306_WIDTH;

    // Draw 8 columns of the character
    for (uint8_t col = 0; col < FONT_8X8_WIDTH; col++)
    {
        // Data is 1 byte (8 rows) per column
        uint8_t data = Font_8x8[char_index][col];
        uint16_t buffer_index = buffer_index_start + col;

        if (!color)
        {
            // Draw in black (clear the bits)
            SSD1306_Buffer[buffer_index] &= ~data;
        }
        else
        {
            // Draw in white (set the bits)
            SSD1306_Buffer[buffer_index] |= data;
        }
    }
    
}
void OLED_DrawString(uint8_t x, uint8_t y, const char *str, bool color)
{
    uint8_t current_x = x;
    while (*str)
    {
        OLED_DrawChar(current_x, y, *str, color);
        
        // Move to the next character position (8 pixels wide)
        current_x += FONT_8X8_WIDTH; 
        str++;

        if (current_x > SSD1306_WIDTH - FONT_8X8_WIDTH)
        {
            break; // Stop drawing if the next character can't fully fit
        }
    }
}

void OLED_DrawProgressBar(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t percentage)
{
    // Clamp percentage to 0-100
    if (percentage > 100) percentage = 100;

    // --- Basic Clipping and Validation ---
    if (x >= SSD1306_WIDTH || y >= SSD1306_HEIGHT || width == 0 || height == 0) return;
    
    // Clip dimensions to screen bounds
    if (x + width > SSD1306_WIDTH) width = SSD1306_WIDTH - x;
    if (y + height > SSD1306_HEIGHT) height = SSD1306_HEIGHT - y;

    // Calculate the width in pixels for the filled part (relative to the bar's total width)
    uint8_t filled_width = (uint8_t)((percentage * width) / 100);

    // Calculate the remaining width for the empty part
    uint8_t empty_width = width - filled_width;

    // Determine the start and end page indices (page = y/8)
    uint8_t start_page = y / 8;
    uint8_t end_page = (y + height - 1) / 8;
    
    // Iterate through the pages spanned by the bar's height
    for (uint8_t page = start_page; page <= end_page; page++)
    {
        // Calculate the base index in the buffer for the start of the bar (x, page)
        uint16_t base_index = (uint16_t)page * SSD1306_WIDTH + x;

        // 1. Fill the progress part: set all 8 vertical pixels (0xFF) for the filled width.
        // This manipulates the buffer from index 'base_index' for 'filled_width' columns.
        memset(&SSD1306_Buffer[base_index], 0xFF, filled_width);
        
        // 2. Clear the remaining part: clear all 8 vertical pixels (0x00).
        // This manipulates the buffer starting right after the filled part.
        memset(&SSD1306_Buffer[base_index + filled_width], 0x00, empty_width);
    }
}